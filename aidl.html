<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>appmart</title>

        <link rel="stylesheet" href="http://appmart-japan.github.io/appmart-inbilling-v2-library/css/bootstrap.min.css">
        <link rel="stylesheet" href="http://appmart-japan.github.io/appmart-inbilling-v2-library/css/font-awesome.min.css">
        <link rel="stylesheet" href="http://appmart-japan.github.io/appmart-inbilling-v2-library/css/highlight.dark.css">
        <link rel="stylesheet" href="http://appmart-japan.github.io/appmart-inbilling-v2-library/css/main.css">
    </head>
    <body>

        <header class="navbar navbar-default navbar-fixed-top">

            <a class="navbar-brand" href="http://appmart-japan.github.io/appmart-inbilling-v2-library/">
                appmart
                <small class="hidden-xs hidden-sm">
                    アプリない課金 V2
                </small>
            </a>

            
        </header>

        <main class="container-fluid">
            <div class="row">

                
                    <nav id="sidebar" class="col-sm-3 col-lg-2" role="navigation">

                        <ul class="nav nav-pills nav-stacked">
                                                            <li class="">
                                    <a href="index.html">
                                        Home
                                    </a>
                                </li>
                                                            <li class="">
                                    <a href="plugin.html">
                                        Plugin方式
                                    </a>
                                </li>
                                                            <li class="active">
                                    <a href="aidl.html">
                                        AIDL方式
                                    </a>
                                </li>
                                                            <li class="">
                                    <a href="cordova.html">
                                        Phonegap
                                    </a>
                                </li>
                                                            <li class="">
                                    <a href="cocos2d.html">
                                        Cocos2d-x V3
                                    </a>
                                </li>
                                                    </ul>

                    </nav>

                
                <section id="content" class="col-sm-offset-3 col-lg-offset-2 col-sm-9 col-lg-10">
                    <h1 id="aidl">AIDL方式</h1>
<p><img src="http://img.shields.io/badge/last%20version-1.1-green.svg" alt="appmartアプリ内課金V2 :1.1" title="appmartアプリ内課金V2 :1.1" />
<img src="http://img.shields.io/badge/license-apache%202.0-brightgreen.svg" alt="license apache 2.0" title="licence apache 2.0" /></p>
<h2 id="">設定+サービス接続</h2>
<h3 id="aidl-1">AIDLファイルの生成</h3>
<p>Appmartの課金システムサービスとやりとりするために、AIDLファイルを作成する必要があります。</p>
<table>
<thead>
<tr>
<th>package名</th>
<th>class名</th>
</tr>
</thead>
<tbody>
<tr>
<td>jp.app_mart.service</td>
<td>　InAppBillingV2Interface.aidl</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">package jp.app_mart.service;

import android.os.Bundle;

interface InAppBillingV2Interface {

    /**
    * バージョンがサポートされているかチェック
    * @param apiVersion アプリ内課金バージョン
    * @return : 0=成功 、 その他=エラー
    */
    int isBillingSupported(int apiVersion);

    /**
    * リターンされるPendingIntentをstartし、決済画面へ遷移
    * @param apiVersion アプリ内課金バージョン
    * @param appId アプリID
    * @param sku サービスID
    * @param licenceKey ライセンスキー
    * @param developerPayload 決済完了リターンされるパラメータ（任意項目）
    * @return returnされるBundleの情報
    *         "RESPONSE_CODE" 0=成功 、 その他=エラー
    *         "BUY_INTENT" - 決済画面へ遷移されるためのPendingIntent
    *               
    *   注意点：   必ずstartIntentSenderForResultでPendingIntentをstartしてください。
    *           　決済後はonActivityResult()が呼ばれ、[resultCode](OK/CANCEL)と[data]がreturnされる。
    *　　　　　　　　決済が正常に完了した場合は,[data]から決済情報を抽出する:
    *           "RESPONSE_CODE" 0=成功 、 その他=エラー
    *           "INAPP_PURCHASE_DATA" - 決済情報（JSON形式）:
    *              '{"orderId":"9999999999999",
    *                "productId":"exampleSku",
    *                "purchaseState":"1",
    *                "developerPayload":"example developer payload" }'
    *         "INAPP_DATA_SIGNATURE" - 購入キー
    */
    Bundle getBuyIntent(int apiVersion, String appId, String sku, String licenceKey, String developerPayload);

     /**
    * 購入可能なサービス情報を問い合わせる(JSON形式)
    * @param apiVersion アプリ内課金バージョン
    * @param appId アプリID
    * @param licenceKey ライセンスキー
    * @param skusBundle 取得するサービスのID（"ITEM_ID_LIST"）：StringArrayList
    * @return returnされるBundleの情報
    *         "RESPONSE_CODE" 0=成功 、 その他=エラー
    *         "DETAILS_LIST" 購入可能なサービスの情報（JSON形式）
    *              '{   "productId" : "exampleSku", 
    *                   "price" : "500",
    *                   "title : "アプリ名", 
    *                   "description" : "アプリ詳細情報" }'
    */
    Bundle getSkuDetails(int apiVersion, String appId, String licenceKey, in Bundle skusBundle);

    /**
    * ユーザーの購入済みサービス情報を問い合わせる
    * @param apiVersion  アプリ内課金バージョン
    * @param appId アプリID
    * @param licenceKey ライセンスキー
    * @return returnされるBundleの情報
    *         "RESPONSE_CODE"   0=成功 、 その他=エラー
    *         "INAPP_PURCHASE_ITEM_LIST" - 購入済みサービスのID (StringArrayList)
    *         "INAPP_PURCHASE_DATA_LIST" - 購入情報 (StringArrayList)
    *              '{   "productId" : "exampleSku", 
    *                   "orderId" : "9999999999999",
    *                   "purchaseTime : "2015/05/01 17:17", 
    *                   "developerPayload" : "example developer payload" }'   
    */
    Bundle getPurchases(int apiVersion, String appId, String licenceKey);

    /**
    * 同じサービスを購入する前に必ず購入を消費しなければなりません。
    * @param apiVersion アプリ内課金バージョン
    * @param sku サービスID
    * @param licenceKey ライセンスキー
    * @param purchaseId 決済ID
    * @return 0=成功 、 その他=エラー
    */
    int consumePurchase(int apiVersion, String sku, String licenceKey, String purchaseId);

}</code></pre>
<blockquote>
<p>必ず上記5つのメソッドを用意してください 。メソッドの引数・戻り値は【リファレンス】を参照してください。</p>
</blockquote>
<h3 id="-1">パーミッション追加</h3>
<p>appmartを利用するには下記permissionsを追加してください。</p>
<pre><code class="language-xml">&lt;!-- 課金API用 --&gt;
&lt;uses-permission android:name="jp.app_mart.permissions.APPMART_BILLING" /&gt;</code></pre>
<h3 id="serviceconnection">ServiceConnectionを作成</h3>
<p>少なくとも以下の処理がアプリ内で必要です。</p>
<ul>
<li>IInAppBillingServiceにバインドします。 </li>
<li>appmart アプリに IPCでbillingリクエストを送ります。 </li>
<li>各billingリクエストごとに返ってくる同期レスポンスメッセージを処理します。 </li>
</ul>
<p>appmartのアプリ内課金サービスへの接続を確立するには、Activityを<strong>InAppBillingV2Interface</strong>にバインドするための ServiceConnection を実装します。<strong>onServiceDisconnected</strong> と <strong>onServiceConnected</strong> メソッドをOverrideし、接続が確立された後に IInAppBillingServiceインスタンスへの参照を取得します。 </p>
<pre><code class="language-java">
InAppBillingV2Interface mService;
ServiceConnection mServiceConn = new ServiceConnection() {
    @Override
    public void onServiceDisconnected(ComponentName name) {
        mService = null;
    }
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        mService = InAppBillingV2Interface.Stub.asInterface((IBinder) service);
    }
};</code></pre>
<h3 id="appmart">Appmartとの連動</h3>
<p>ActivityのonCreateメソッド内で、<strong>bindService</strong>メソッドを呼んでバインドします。メソッドには アプリ内課金サービスを参照するIntentおよびServiceConnectionのインスタンスを渡します。</p>
<pre><code class="language-java">Intent serviceIntent = new Intent();
serviceIntent.setClassName("jp.app_mart", "jp.app_mart.service.AppmartInBillingV2Service");

if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
    mContext.bindService(serviceIntent, mServiceConn,Context.BIND_AUTO_CREATE);
} else {
    if (listener != null) {
        listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
                "Billing service unavailable on device."));
    }
}</code></pre>
<blockquote>
<p><strong>注意点</strong>：Activityが終了する場合、サービスからのアンバインドを忘れずに行ってください。</p>
</blockquote>
<pre><code class="language-java">@Override
public void onDestroy() {
    super.onDestroy();
    if (mService != null){
        unbindService(mServiceConn);
    }
}</code></pre>
<p>サービスが購入されると、ユーザーがそのサービスの<strong>所有権</strong>を取得したと認識し、そのサービスが<strong>消費されるまで</strong>同じプロダクトIDのサービスが購入されるのを防止します。アプリではサービスがどのように消費されるかをコントロールすることができ、appmartにそのサービスが<strong>再度購入</strong>できるようになったことを通知できます。また、ユーザーによって作成された購入リストをappmartから素早く取得することができます。例えば、ユーザーがアプリを起動したときにユーザーの購入リストをリストアしたときに便利です。</p>
<h3 id="-2">購入可能なサービス情報を問い合わせ</h3>
<p>ユーザーの購入状況と関係なくappmartからサービスの詳細を問い合わせることができます。アプリ内課金V2サービスにリクエストを送るには、サービスIDの String ArrayList を作成し、それを &quot;ITEM_ID_LIST&quot; というキーで Bundle に保持します。 </p>
<pre><code class="language-java">ArrayList&lt;String&gt; skuList = new ArrayList&lt;String&gt; ();
skuList.add("my_first_service_id");
skuList.add("my_second_service_id");
Bundle querySkus = new Bundle();
querySkus.putStringArrayList(“ITEM_ID_LIST”, skuList);</code></pre>
<p>appmart から情報を取得するには、アプリ内課金V2 の<strong>getSkuDetails</strong> メソッドを呼び出します。第1引数には アプリ内課金 version の &quot;2&quot;、第2引数には呼び出しアプリのID、
第3引数には作成した Bundle を渡します。</p>
<pre><code class="language-java">// appmartにサービス情報を問い合わせる
Bundle skuDetails = mService.getSkuDetails(2, "application_id", "license_key", querySkus);</code></pre>
<p>リクエストが成功した場合、返ってきた Bundle には RESPONSE_CODE というキーで 0 が含まれます。 </p>
<h3 id="response-code-">Response Code 一覧:</h3>
<table>
<thead>
<tr>
<th>値</th>
<th>備考</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>成功</td>
</tr>
<tr>
<td>1</td>
<td>ユーザーが[back]キーを押しました</td>
</tr>
<tr>
<td>4</td>
<td>指定されたサービスイDが購入不可能</td>
</tr>
<tr>
<td>5</td>
<td>渡された引数が正しくありません</td>
</tr>
<tr>
<td>6</td>
<td>致命的なエラーが発生</td>
</tr>
<tr>
<td>7</td>
<td>所有権あり</td>
</tr>
<tr>
<td>8</td>
<td>所有権がないため、消費不可能</td>
</tr>
</tbody>
</table>
<blockquote>
<p>getSkuDetails メソッドをメインスレッドから呼ばないでください。このメソッドはネットワークリクエストのトリガーになり、メインスレッドをブロックします。 </p>
</blockquote>
<p>問い合わせた結果は、&quot;DETAIL_LIST&quot; というキーで String ArrayList に格納され、各購入情報は JSON 形式の文字列で格納されます。</p>
<pre><code class="language-java">int response = skuDetails.getInt("RESPONSE_CODE");
if (response == 0) {
   ArrayList&lt;String&gt; responseList
      = skuDetails.getStringArrayList("DETAILS_LIST");

   for (String thisResponse : responseList) {
      JSONObject object = new JSONObject(thisResponse);
      String sku = object.getString("productId");
      String price = object.getString("price");
      // TODO UIを更新
   }
}</code></pre>
<h3 id="json">JSON項目一覧：</h3>
<table>
<thead>
<tr>
<th>json項目</th>
<th>備考</th>
</tr>
</thead>
<tbody>
<tr>
<td>productId</td>
<td>サービスID</td>
</tr>
<tr>
<td>price</td>
<td>サービスの価格 (例：¥120)</td>
</tr>
<tr>
<td>title</td>
<td>サービス名</td>
</tr>
<tr>
<td>description</td>
<td>サービス説明</td>
</tr>
<tr>
<td>price_currency_code</td>
<td>通貨</td>
</tr>
</tbody>
</table>
<h3 id="-3">サービス購入</h3>
<p>アプリから購入リクエストを開始するには、getBuyIntentメソッドを呼び出します。 第1引数にはアプリ内課金<strong>version</strong>の&quot;2&quot;、第2引数には呼び出し<strong>アプリID</strong>、第3引数には<strong>サービス ID</strong>、第4引数にはアプリのライセンスキー、第4引数には <strong>developerPayload</strong> 文字列を渡します。 developerPayload 文字列は、購入情報としてappmartから返してほしい付加的な引数を指定するのに使います。 </p>
<pre><code class="language-java">Bundle buyIntentBundle = mService.getBuyIntent(2, "application_id", "my_service_id", "license_key", "developer_pay_load");</code></pre>
<p>リクエストが成功した場合、返ってきた Bundle には RESPONSE_CODE というキーで <strong>0</strong> が含まれます。また、&quot;BUY_INTENT&quot; というキーで取得できる PendingIntent で購入フローを開始出来ます。</p>
<pre><code class="language-java">PendingIntent pendingIntent = buyIntentBundle.getParcelable("BUY_INTENT");</code></pre>
<p>購入処理を完了するには、取得したpendingIntentで<strong>startIntentSenderForResult</strong>メソッドを呼び出します。</p>
<pre><code class="language-java">startIntentSenderForResult(pendingIntent.getIntentSender(),
    1001, new Intent(), Integer.valueOf(0), Integer.valueOf(0),
    Integer.valueOf(0));</code></pre>
<p>PendingIntentのレスポンスをアプリのonActivityResultに返します。onActivityResultメソッドはActivity.RESULT_OK (1) もしくは Activity.RESULT_CANCELED (0) を resultCode として持ちます。</p>
<table>
<thead>
<tr>
<th>値</th>
<th>備考</th>
</tr>
</thead>
<tbody>
<tr>
<td>RESPONSE_CODE</td>
<td>　0=成功</td>
</tr>
<tr>
<td>INAPP_PURCHASE_DATA</td>
<td>購入情報をもつJSON文字列</td>
</tr>
<tr>
<td>INAPP_DATA_SIGNATURE</td>
<td>デベロッパーの公開鍵で暗号化された決済ID</td>
</tr>
</tbody>
</table>
<p>購入データは JSON 形式の文字列として Intent に格納されており、&quot;INAPP_PURCHASE_DATA&quot; というキーで取得できます。 </p>
<pre><code class="language-js">{   
   "orderId":"1299976316905",   
   "packageName":"com.example.app",  
   "productId":"exampleSku",  
   "developerPayload":"developer_payload",   
 }</code></pre>
<blockquote>
<p>onActivityResultの実装</p>
</blockquote>
<pre><code class="language-java"> @Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
   if (requestCode == 1001) {
      int responseCode = data.getIntExtra("RESPONSE_CODE", 0);
      String purchaseData = data.getStringExtra("INAPP_PURCHASE_DATA");
      String dataSignature = data.getStringExtra("INAPP_DATA_SIGNATURE");

      if (resultCode == RESULT_OK) {
         try {
            JSONObject jo = new JSONObject(purchaseData);
            String sku = jo.getString("productId");
            alert("You have bought the " + sku );
          }
          catch (JSONException e) {
             alert("Failed to parse purchase data.");
             e.printStackTrace();
          }
      }
   }
}</code></pre>
<blockquote>
<p>セキュリティー向上のためdeveloperPayloadの文字列が以前に送った購入リクエストのものと一致するかチェックします。 </p>
</blockquote>
<h3 id="-4">購入したサービスを問い合わせる</h3>
<p>ユーザーによる購入情報を取得するには、アプリ内課金V2のgetPurchasesメソッドを呼び出します。第1引数には <strong>アプリ内課金version</strong>の &quot;2&quot;、第2引数には呼び出し<strong>アプリのID</strong>、第3引数には<strong>ライセンスキー</strong>を渡します。 </p>
<pre><code class="language-java"> Bundle ownedServices = mService.getPurchases(2, "application_id", "license_key");</code></pre>
<p>appmartサービスは、デバイスに現在ログインしているユーザーアカウントの購入についてのみ返します。リクエストが成功した場合、返ってきた Bundle には RESPONSE_CODE というキーで <strong>0</strong> が含まれます。また、&quot;INAPP_PURCHASE_ITEM_LIST&quot; というキーで product ID のリストが、&quot;INAPP_PURCHASE_DATA_LIST&quot; というキーでオーダー詳細のリストが含まれます。</p>
<pre><code class="language-java"> int response = ownedItems.getInt("RESPONSE_CODE");
if (response == 0) {
   ArrayList&lt;String&gt; ownedSkus =  ownedItems.getStringArrayList("INAPP_PURCHASE_ITEM_LIST");
   ArrayList&lt;String&gt;  purchaseDataList =  ownedItems.getStringArrayList("INAPP_PURCHASE_DATA_LIST");

   for (int i = 0; i &lt; purchaseDataList.size(); ++i) {
      String purchaseData = purchaseDataList.get(i);
      String sku = ownedSkus.get(i);

      // do something with this purchase information
      // e.g. display the updated list of products owned by user
   }

   // if continuationToken != null, call getPurchases again
   // and pass in the token to retrieve more items
}</code></pre>
<h3 id="-5">購入サービスの消費</h3>
<p>アプリ内課金V2を使って、appmartの購入されたサービスの所有権をトラックできます。一度サービスが購入されると、その所有権があると考えられappmartから購入できなくなります。appmart が再びサービスを購入可能にする前に、サービスの消費リクエストを送らなければなりません。 </p>
<p>消費メカニズムをどう利用するかは開発者次第になります。
典型的には、ユーザーが複数回購入したいような一時的な利益があるプロダクト（例えばゲーム内通貨や装備）は消費可能な実装にします。一度だけ購入したり、永続的な効果を提供するプロダクト（例えばプレミアムアップグレード）は消費しないように実装します。 </p>
<p>購入サービスの消費を記録するには、consumePurchaseメソッドを呼び出します。第1引数にはアプリ内課金versionの&quot;2&quot;、第2引数には呼び出しアプリのサービスID、第3引数にはライセンスキー、第4引数には決済IDを渡します。</p>
<pre><code class="language-java">int response = mService.consumePurchase(2, "my_first_service", "license_key", "9999999999999");</code></pre>
<p>consumePurchase はメインスレッドから呼び出さないでください。このメソッドはネットワークリクエストのトリガーになり、メインスレッドをブロックします。 </p>
<p>購入したサービスがユーザーにどのように提供されるかをコントロールしトラックするかは開発者の責任です。例えば、ゲーム内通貨をユーザーが購入した場合、購入した通貨の量に応じてプレイヤーの状態を変えなければなりません。 </p>
<p>Security Recommendation: ユーザーにアプリ内課金を消費する利益をプロビジョニングする前に消費リクエストを送らなければなりません。サービスをプロビジョンする前にappmartから成功した消費レスポンスを受けとっていることを確認します。</p>
                </section>

            </div>
        </main>

        <footer>
            <div class="container-fluid">
                <p class="text-muted">
                    By <a href="http://app-mart.jp" title="app-mart アプリ内課金">appmart</a>
                </p>
            </div>
        </footer>

        <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
        <script src="//yastatic.net/highlightjs/8.2/highlight.min.js"></script>

        <script>
            $(function() {
                $("section>h1").wrap('<div class="page-header" />');
                // Syntax highlighting
                hljs.initHighlightingOnLoad();
            });
        </script>

    </body>
</html>
